
/* Author: Divyanshu Kakwani */

#include <iostream>
#include <cmath>
#include <bitset>
#include <list>

/* Quick Overview:
 * Tau(n) is computed as follows:
 *  If the prime factorization of n = a^i * b^j * c^k, then tau(n) = (i+1)(j+1)(k+1)
 * The prime factorization of n is computed using the usual successive division by primes
 * in ascending order. 
 * Lastly, the prime numbers in ascending order are generated by an object of class
 * PrimeGenerator.
 */


/* The maximum value of the input number */
static const long long upper_limit = 10e12;

// Generate primes till `till`, excluding `till`
template<long long till>
class PrimeGenerator {
 private:   
    std::bitset<till>              sieve;
    std::list<long long>           prime_list;
    std::list<long long>::iterator it;
 
 public:
    PrimeGenerator() {
        // Sieving Operation
        for (long long num = 2; num < sqrt(till); num++)
            for (long long multiple = 2 * num; multiple < till; multiple += num)
              sieve.set(multiple);

        // Generate the list
        for (long long num = 2; num < till; num++)
            if (!sieve.test(num))  prime_list.push_back (num);
    }
    void reset() {
        it = prime_list.begin(); 
    }
    long long next() {
        long long num = *it;
        it++;
        return num;
    }
};


template<long long till>
class Tau {
 private:
     PrimeGenerator<static_cast<long long>(sqrt(till))> gen;
 
 public:
    Tau() = default;

    long long operator()(long long num) {
        gen.reset();
        
        /* stores just the exponents of the prime divisors of num */
        std::list<int> exponents;

        while (true) {
            long long prime = gen.next();
            if (num <= 1 or prime * prime > num)    break;
            int times = 0;
            for (; num % prime == 0; times++, num /= prime);
            if(times)   exponents.push_back(times); 
        }
        /* If at the end of the above loop, number > 1, then there exists some 
         * prime factor > sqrt(num); Hence, push back 1;
         */
        if(num > 1)   exponents.push_back(1);

        /* if num = a^p * b^q * c^r, then tau(n) = (p+1)(q+1)(r+1) */
        long long product = 1;
        for(int exp : exponents)    product *= exp + 1;

        return product;
    }
};

int main() {
    long long t, n;
    Tau<upper_limit> tau; 
    std::cin >> t;
    while (t--) { std::cin >> n; std::cout << tau(n) << std::endl; }
}
